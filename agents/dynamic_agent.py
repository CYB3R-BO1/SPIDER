from typing import Dict, List, Optional, Tuple

from storage.graph_store import GraphStore
from bus.event_bus import EventBus


class DynamicAgent:
    """
    Executes the binary in a controlled environment.
    Responsibilities:
    - Use gdb, QEMU, or ptrace for step-by-step tracing.
    - Capture register states, memory changes, and executed BBs.
    - Build dynamic execution paths for comparison with static CFG.
    - Submit dynamic facts to the graph store.
    - Publish DYNAMIC_TRACE_READY.
    """

    def __init__(self, graph_store: GraphStore, bus: Optional[EventBus] = None):
        self.g = graph_store
        self.bus = bus

    def run(self, binary_path: str, run_id: str = "run_1"):
        try:
            from pygdbmi.gdbcontroller import GdbController
        except Exception as exc:
            raise RuntimeError(
                "pygdbmi is required for DynamicAgent. Install it to proceed."
            ) from exc

        bb_addrs = self.g.fetch_all_basic_blocks()
        if not bb_addrs:
            return

        self.g.create_run(run_id, binary_path)

        gdbmi = None
        try:
            gdbmi = GdbController(
                command=["gdb", "--interpreter=mi2", binary_path]
            )
            self._send_cmd(gdbmi, "-gdb-set pagination off")
            self._send_cmd(gdbmi, "-gdb-set confirm off")

            for addr in bb_addrs:
                self._send_cmd(gdbmi, f"-break-insert *0x{addr:x}")

            self._send_cmd(gdbmi, "-exec-run")

            reg_names = self._get_register_names(gdbmi)
            seen_blocks = set()
            last_bb = None
            seq = 0
            pending_stop = None

            while True:
                stop = pending_stop or self._wait_for_stop(gdbmi)
                pending_stop = None
                if stop is None:
                    break
                reason = stop.get("reason")
                if reason and "exited" in reason:
                    break
                if reason != "breakpoint-hit":
                    continue

                pc = self._parse_addr(stop)
                if pc is None:
                    pc = self._read_pc(gdbmi)
                if pc is None:
                    continue

                regs = self._get_register_values(gdbmi, reg_names)
                next_pc, pending_stop = self._step_for_next_pc(gdbmi)

                self.g.add_executes_edge(
                    run_id=run_id,
                    bb_addr=pc,
                    seq=seq,
                    pc=pc,
                    next_pc=next_pc if next_pc is not None else pc,
                    regs=regs,
                )
                if last_bb is not None:
                    self.g.add_runtime_flow(
                        run_id=run_id,
                        src_bb=last_bb,
                        dst_bb=pc,
                        seq=seq,
                        pc=pc,
                        next_pc=next_pc if next_pc is not None else pc,
                        regs=regs,
                    )

                seq += 1
                if pc in seen_blocks:
                    break
                seen_blocks.add(pc)
                last_bb = pc

                if pending_stop is None:
                    self._send_cmd(gdbmi, "-exec-continue")

        finally:
            if gdbmi is not None:
                try:
                    gdbmi.exit()
                except Exception:
                    pass

        if self.bus is not None:
            self.bus.publish(
                "DYNAMIC_TRACE_READY", {"run_id": run_id, "binary": binary_path}
            )

    # ---------------------------
    # GDB Helpers
    # ---------------------------

    def _send_cmd(self, gdbmi, cmd: str):
        gdbmi.write(cmd)

    def _wait_for_stop(self, gdbmi, timeout_sec: float = 1.0):
        while True:
            responses = gdbmi.get_gdb_response(timeout_sec=timeout_sec)
            if not responses:
                return None
            for resp in responses:
                if resp.get("type") == "result" and resp.get("message") == "stopped":
                    payload = resp.get("payload", {})
                    if isinstance(payload, dict):
                        return payload

    def _parse_addr(self, stop_payload: Dict) -> Optional[int]:
        frame = stop_payload.get("frame")
        if not isinstance(frame, dict):
            return None
        addr = frame.get("addr")
        if isinstance(addr, str):
            try:
                return int(addr, 16)
            except Exception:
                return None
        if isinstance(addr, int):
            return addr
        return None

    def _read_pc(self, gdbmi) -> Optional[int]:
        gdbmi.write("-data-evaluate-expression $pc")
        responses = gdbmi.get_gdb_response(timeout_sec=1.0)
        for resp in responses:
            if resp.get("type") == "result" and resp.get("message") == "done":
                payload = resp.get("payload", {})
                value = payload.get("value")
                if isinstance(value, str):
                    try:
                        return int(value, 0)
                    except Exception:
                        return None
        return None

    def _get_register_names(self, gdbmi) -> List[str]:
        gdbmi.write("-data-list-register-names")
        responses = gdbmi.get_gdb_response(timeout_sec=1.0)
        for resp in responses:
            if resp.get("type") == "result" and resp.get("message") == "done":
                payload = resp.get("payload", {})
                names = payload.get("register-names")
                if isinstance(names, list):
                    return [n for n in names if isinstance(n, str)]
        return []

    def _get_register_values(self, gdbmi, reg_names: List[str]) -> Dict:
        gdbmi.write("-data-list-register-values x")
        responses = gdbmi.get_gdb_response(timeout_sec=1.0)
        for resp in responses:
            if resp.get("type") == "result" and resp.get("message") == "done":
                payload = resp.get("payload", {})
                values = payload.get("register-values")
                if not isinstance(values, list):
                    return {}
                regs = {}
                for item in values:
                    if not isinstance(item, dict):
                        continue
                    idx = item.get("number")
                    val = item.get("value")
                    if isinstance(idx, str):
                        try:
                            idx = int(idx, 10)
                        except Exception:
                            continue
                    if isinstance(idx, int) and idx < len(reg_names):
                        name = reg_names[idx]
                        regs[name] = val
                return regs
        return {}

    def _step_for_next_pc(self, gdbmi) -> Tuple[Optional[int], Optional[Dict]]:
        self._send_cmd(gdbmi, "-exec-step-instruction")
        stop = self._wait_for_stop(gdbmi)
        if stop is None:
            return None, None
        next_pc = self._parse_addr(stop)
        if next_pc is None:
            next_pc = self._read_pc(gdbmi)
        if stop.get("reason") == "breakpoint-hit":
            return next_pc, stop
        return next_pc, None
